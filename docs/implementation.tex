
\section{Implementation}

% TODO do gentle introductino
\subsection{Multi Level OCaml Syntax Extensions}

To facilitate multi-level features in OCaml, source programs must now use special multi-level operations. These are implemented as a special syntax extensions to the language. Below example demonstrates what these syntax extensions look like:

\begin{minted}{ocaml}
(* Normal single-stage add program *)
let add a b = a + b
(* multi-level add program *)
[%%ml let add a b = [%add 2
          [%lift 1 1 a]
          [%lift 2 b]]]
\end{minted}

As the above example demonstrates, multi-level programs are first decorated with the special \texttt{[\%\%ml ...]} syntax extension. This tells the multi-level compiler generator to treat the add program as a multi-level program. Within the \texttt{add} function, a syntax extension \texttt{[\%add t e1 e2]} is used. This means that add is a special multi-level code-generating addition function. Similarly, \texttt{lift} is also a syntax extension that, and the meaning of both operators is explained in the subsequent sections.

\subsection{Multi Level OCaml}

The multi-level extensions to OCaml is called \textit{mocaml}, and the abstract syntax of the language is similar to \textit{MetaScheme} presented in \cite{multilevel}.
Each multi-level construct of mocaml has an associated binding time $t \ge 0$ as an additional argument. In the above add program, the multi-level add operator has binding time \texttt{t=2}. The abstract syntax of \texttt{mocaml} is:

\begin{gather*}  
  \boxed{    
    \begin{aligned}
      &p\in Program; x\in Variable; d\in Definition; c\in Constant;\\
      &e \in Constant; s,t \in BindingTime
    \end{aligned}
  }\\
  \hspace{1cm}
  \begin{align*}
    p :=&~d_1,...,d_m\\
    d :=&~\text{\texttt{[\%\%let f x1 ... x2 = e]}}\\
    |~& \text{\texttt{let p\_mgen = [\%run f e]}}\\
    e :=&~c ~|~x ~|~\text{\texttt{if b then e1 else e2}}\\
    |&~\text{\texttt{[\%add t e1 e2]}}
       ~|~\text{\texttt{[\%sub t e1 e2]}}
       ~|~\text{\texttt{[\%mul t e1 e2]}}\\
    |&~\text{\texttt{[\%div t e1 e2]}}
       ~|~\text{\texttt{[\%app t f e]}}
       ~|~\text{\texttt{[\%lift s t e]}}
       ~|~\text{\texttt{[\%lift t e]}}\\
    b :=&~\mathtt{true} ~|~\mathtt{false} ~|~\text{\texttt{e1 < e2}}
  \end{align*}
\end{gather*}

The operator \texttt{[\%lift s t e]} is equivalent to the definition in \cite{multilevel} and it coerces an expression of binding time \texttt{t} to an expression of binding time \texttt{s+t}. Similarly, \texttt{[\%lift t e]} is a shorthand for \texttt{s=0}. Currently, there is also a limitation that \texttt{app} can only be used to make recursive calls and not call arbitrary functions.

\subsection{Program representation}

Unlike Lisp, OCaml does not provide the ability to treat code as data, and a generating extension can not be represented in code as a multi-level program and a library for code generation and specialization as it is done in \cite{multilevel}. However, like in \cite{multilevel}, mocaml still only modifies the AST of OCaml.
The \texttt{[\%run f e]} ocaml syntax extension gets the ParseTree\footnote{This is a tree sturcuture generated by the OCaml compiler after parsing and before type checking.} for \texttt{f}, and lifts it to a more manageable DSL that can handle specialization and code generation. This was inspired by the approach to two-level annotations by \cite{metaML} and \cite{metaOCaml}. Below are the type definitions for the mocaml DSL:

\begin{listing}[H]
\begin{minted}{ocaml}
type ml_val = Val of int | Ident of string
and ml_expr = { (* Wrapper to store binding time info *)
  v: ml_val;
  t: int;
}

type ml_cond = Leq of ml_ops * ml_ops
             | Bool of bool

and ml_binop = Add of ml_ops * ml_ops
             | Sub of ml_ops * ml_ops
             | Mul of ml_ops * ml_ops
             | Div of ml_ops * ml_ops
and ml_ops = Binop of int * ml_binop
           | Expr of ml_expr
           | Lift of int * ml_ops
           | Fun of string * ml_ops
           | IfElse of ml_cond * ml_ops * ml_ops
           | App of int * string * (ml_ops list)
\end{minted}
  % TODO: Make sure it is understandable what the DSL is and how we have to abstract syntax
\caption{Type signature for mocaml operations and expressions. These correspond to the abstract syntax of mocaml.}
\label{lst:dsl}
\end{listing}

As it can be seen, the types correspond to the definitions of the abstract syntax of mocaml. The only base type allowed for mocaml is currently integers. The \texttt{ml\_expr} type is used to store binding time info of leaf nodes such as constants and argument identifiers. This way, an expression like \texttt{[\%lift 2 3]} can be compactly represented as an \texttt{ml\_expr} with \texttt{v=Val 3} and binding time $t=2$.
It was briefly mentioned that specialization and code generation works on the DSL defined by the above types. Program generation itself happens in two stages:
\begin{itemize}
\item When the \texttt{[\%run ml\_func arg]} annotation is used, the syntax tree of the \texttt{ml\_func} is lifted into the above types and specialization takes place.
  
\item Then, code generation is conducted on the specialization. It is still possibly to further specialize the result given more arguments.
\end{itemize}

\subsection{Program Specilization}

For a first example of hand writing program generators in mocaml consider the below listing \ref{lst:mul}. The multi level program \texttt{mul\_ml} is declared in the top left, and then specialized with respect to an input using the \texttt{run} primitive. The generated residual program is shown at the bottom. For reference, a semantically equivalent OCaml program is shown at the top right. The mocaml program is decorated with multi level operations and binding time information, but otherwise looks almost identical to the OCaml program. The same structure of \texttt{if-then-else} is used and the same operations are also used by the mocaml program.

\begin{figure}[H]
  \centering
  \begin{subfigure}[t]{0.49\textwidth}
\begin{minted}{ocaml}
[%%ml let mul_ml n m =
if [%lift 1 n] < [%lift 1 1]
then [%lift 2 0]
else
  [%add 2
      [%lift 2 m]
      [%app 2
          (mul_ml
             [%sub 1
               [%lift 1 n]
               [%lift 1 1]
             ]
             [%lift 2 m])]]
]
\end{minted}
    \subcaption{Multi-level program}
    \label{fig:ml_mul}
  \end{subfigure}
  \begin{subfigure}[t]{0.49\textwidth}
\begin{minted}{ocaml}
let rec mul n m =
if n < 1
then 0
else m + mul (n - 1) m
\end{minted}
    \subcaption{OCaml source program}
    \label{fig:mul}
  \end{subfigure}
  \begin{subfigure}[c]{0.49\textwidth}   
\begin{minted}{ocaml}
let res m = [%add 1
  [%lift 1 m]
  [%add 1
    [%lift 1 m]
    [%add 1
      [%lift 1 m]
      [%lift 1 0]]]]
\end{minted}
    \subcaption{Generated residual program with n=3}
    \label{fig:mul_res}
  \end{subfigure}
  \begin{subfigure}{0.49\textwidth}
\begin{minted}{ocaml}
let res2 = 6
\end{minted}
    \subcaption{Second specialization with $m=2$.}
    \label{fig:mul_final_res}
  \end{subfigure}
  \caption{Multi-level specialization of a multiplication program.}
  \label{lst:mul}
\end{figure}
As it was previously mentioned in listing \ref{lst:dsl}, \texttt{run} lifts a multi-level mocaml program into a OCaml DSL, and specialization then works on the DSL. The specializer works similar to the library described in \cite{multilevel}. For instance, when an operation like \texttt{add} or \texttt{sub} is hit by the sepcializer, it is checked whether the binding time is $t=1$, in which case the underlying OCaml implementation is used to calculate the result. Otherwise, the binding time is simply decreased by one. As a consequence of this, the residual program in figure \ref{fig:mul_res} has the bounds check and recursive calls have been eliminated by the specialization. For large inputs, specialization of recursive functions might lead to code explosion. Also note that if the residual program is specialized once more, then all constructs have binding time $t=1$, and we have a situation similar to traditional offline two-level partial evaluation where (in this case) all inputs are static and a result can be calculated. The resulting program after a second specialization is shown in figure \ref{fig:mul_final_res}.


%%% Local Variables:
%%% TeX-command-extra-options: "-shell-escape"
%%% mode: LaTeX
%%% TeX-master: "mocaml"
%%% End:
